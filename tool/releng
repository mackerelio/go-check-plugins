#!/usr/bin/env perl

=head DESCRIPTION

Release Engineering script for mackerel related packages.

=head SYNOPSIS

    % releng
        --help
        --task=<task>            # 'github-release'
        --package-name=<name>    # target package name. if not specified,
                                 # the repository name is used.
        --dry-run

=head DEPENDENCY

`git` command and `hub` command and `github-release` command are required.

=cut

use 5.014;
use strict;
use warnings;
use utf8;

use FindBin;
use lib $FindBin::Bin;
use MCUtil qw/http_get command infof warnf/;

use JSON::PP qw/decode_json/;
use Getopt::Long qw/GetOptions :config auto_help/;
use Pod::Usage qw/pod2usage/;
use File::Basename qw/basename/;

chomp(my $path = `git rev-parse --show-toplevel`);
my @directories = split m!/!, $path;

my $REPO  = $directories[-1];
my $OWNER = $directories[-2];

my $dry_run;
my $package_name = $REPO;

sub github_release {
    if ($dry_run) {
        return;
    }
    state $com = do {
        chomp(my $c = `which github-release`);
        die "github-release command is required\n" unless $c;
        $c;
    };
    unshift  @_, $com; goto \&command
}

sub next_version {
    state $v = do {
        my $next = `git log --merges --oneline`;
        my ($v) = $next =~ /^.+Merge pull request #[0-9]+ from .+\/bump-version-([0-9\.]+)$/m;
        $v;
    };
}

sub find_latest_release_pullrequest {
    my $url = sprintf "https://api.github.com/repos/%s/%s/pulls?state=close&sort=updated&direction=desc", $OWNER, $REPO;
    my $res = http_get($url);
    unless ($res->{success}) {
        warnf "request to $url failed\n";
        return; #exit;
    }
    my $data = eval { decode_json $res->{content} };
    if ($@) {
        warnf "parse json failed. url: $url\n";
        return;
    }
    for my $pull (@$data){
        if($pull->{head}{ref} =~ /bump-version-[0-9\.]+/){
            return $pull;
        }
    }
}

sub upload_to_github_release {
    chomp(my $current_branch = `git symbolic-ref --short HEAD`);
    return unless $current_branch eq 'master';

    my $tag = shift || "v" . next_version();
    my $name = shift || $REPO . "-" . next_version();
    my $erase_if_exist = shift || 0;
    while (1) {
        eval { github_release qw/release --user/, $OWNER,
            qw/--repo/, $REPO,
            qw/--tag/, $tag,
            qw/--name/, $name,
            qw/--description/, "pre-release",
            qw/--pre-release/
        };
        if (!$@) {
            last;
        }
        if (!$erase_if_exist) {
            infof "The release of this version has already existed at GitHub Release, so skip the process.\n";
            return;
        }

        eval { github_release qw/delete --user/, $OWNER,
            qw/--repo/, $REPO,
            qw/--tag/, $tag
        };
        if ($@) {
            infof "The release of this version has already existed at GitHub Release, and cannot be erased.\n";
            return;
        }
    }

    # upload files
    my $latest_release_pullrequest = find_latest_release_pullrequest();
    my $description = $latest_release_pullrequest->{body};
    my @filepaths = glob("~/rpmbuild/RPMS/*/*.rpm packaging/*.deb snapshot/*.zip snapshot/*.tar.gz");
    infof "uploading following files:\n" . join("\n", @filepaths). "\n";
    for my $path (@filepaths){
        my $filename = basename($path);
        github_release qw/upload --user/, $OWNER,
            qw/--repo/, $REPO,
            qw/--tag/, $tag,
            qw/--name/, $filename,
            qw/--file/, $path;
    }
    my @args = (qw/edit --user/, $OWNER,
        qw/--repo/, $REPO,
        qw/--tag/, $tag,
        qw/--description/, $description);
    push @args, "--pre-release" if $erase_if_exist;
    github_release @args;
}

### main process
if (!$ENV{HARNESS_ACTIVE}) {
    main();
} else {
    # When called via `prove`, tests will run.
}

sub main {
    my $task;
    GetOptions (
        "task=s"           => \$task,
        "dry-run"          => \$dry_run,
        "package-name=s"   => \$package_name,
    ) or pod2usage(1);

    if ($task && $task eq "upload-to-github-release") {
        infof "Upload files to GitHub Release.\n";
        upload_to_github_release();
    } elsif ($task && $task eq "upload-master-to-github-release") {
        infof "Upload files on master branch to GitHub Release.\n";
        upload_to_github_release("staging", "staging", 1);
    }
}
