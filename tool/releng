#!/usr/bin/env perl

=head DESCRIPTION

Release Engineering script for mackerel related packages.

=head SYNOPSIS

    % releng
        --help
        --task=<task>            # 'github-release'
        --dry-run

=head DEPENDENCY

`git` command and `hub` command and `github-release` command are required.

=cut

use 5.014;
use strict;
use warnings;
use utf8;

use Mackerel::ReleaseUtils qw/command/;
use Mackerel::ReleaseUtils::Log qw/infof warnf/;

use HTTP::Tinyish;
use JSON::PP qw/decode_json/;
use Getopt::Long qw/GetOptions :config auto_help/;
use Pod::Usage qw/pod2usage/;
use File::Basename qw/basename/;

chomp(my $path = `git rev-parse --show-toplevel`);
my @directories = split m!/!, $path;

my $REPO  = $directories[-1];
my $OWNER = $directories[-2];

my $dry_run;

sub github_release {
    if ($dry_run) {
        return;
    }
    state $com = do {
        chomp(my $c = `which github-release`);
        die "github-release command is required\n" unless $c;
        $c;
    };
    unshift  @_, $com; goto \&command
}

sub next_version {
    state $v = do {
        my $next = `git log --merges --oneline`;
        my ($v) = $next =~ /^.+Merge pull request #[0-9]+ from .+\/bump-version-([0-9\.]+)$/m;
        $v;
    };
}

sub find_latest_release_pullrequest {
    my $url = sprintf "https://api.github.com/repos/%s/%s/pulls?state=close&sort=updated&direction=desc", $OWNER, $REPO;
    my $res = HTTP::Tinyish->new->get($url);
    unless ($res->{success}) {
        warnf "request to $url failed\n";
        return; #exit;
    }
    my $data = eval { decode_json $res->{content} };
    if ($@) {
        warnf "parse json failed. url: $url\n";
        return;
    }
    for my $pull (@$data){
        if($pull->{head}{ref} =~ /bump-version-[0-9\.]+/){
            return $pull;
        }
    }
}

sub upload_to_github_release {
    my %args = @_;

    chomp(my $current_branch = `git symbolic-ref --short HEAD`);
    return unless $current_branch eq 'master';

    my $is_staging = $args{staging};
    my ($tag, $name) = ("staging")x2;
    if (!$is_staging) {
        ($tag, $name) = ("v" . next_version(), $REPO . "-" . next_version());
    }

    my $release_api_url = sprintf 'https://api.github.com/repos/%s/%s/releases/tags/%s', $OWNER, $REPO, $tag;
    my $status = `curl -s -I $release_api_url -o /dev/null -w '\%{http_code}'`;
    if ($?) {
        warnf "curl failed\n";
        return;
    }

    if ($status == 200) {
        if (!$is_staging) {
            infof "The release of this version has already existed at GitHub Release, so skip the process.\n";
            return;
        }
        else {
            github_release qw/delete --user/, $OWNER,
                qw/--repo/, $REPO,
                qw/--tag/, $tag;
        }
    }
    elsif ($status != 404) {
        warnf "something went wrong while requesting github api. url:%s, status: %d", $release_api_url, $status;
        return;
    }

    my $latest_release_pullrequest = find_latest_release_pullrequest();
    unless ($latest_release_pullrequest) {
        warnf "faild to find latest release pull request";
        return
    }

    my $description = $latest_release_pullrequest->{body};
    github_release qw/release --user/, $OWNER,
        qw/--repo/, $REPO,
        qw/--tag/, $tag,
        qw/--name/, $name,
        qw/--description/, $description,
        qw/--pre-release/;

    # upload files
    my @filepaths = glob("~/rpmbuild/RPMS/*/*.rpm packaging/*.deb snapshot/*.zip snapshot/*.tar.gz");
    infof "uploading following files:\n" . join("\n", @filepaths). "\n";
    for my $path (@filepaths){
        my $filename = basename($path);
        github_release qw/upload --user/, $OWNER,
            qw/--repo/, $REPO,
            qw/--tag/, $tag,
            qw/--name/, $filename,
            qw/--file/, $path;
    }
    if (!$is_staging) {
        github_release qw/edit --user/, $OWNER,
            qw/--repo/, $REPO,
            qw/--tag/, $tag,
            qw/--name/, $name,
            qw/--description/, $description;
    }
}

### main process
if (!$ENV{HARNESS_ACTIVE}) {
    main();
} else {
    # When called via `prove`, tests will run.
}

sub main {
    my $task;
    GetOptions (
        "task=s"  => \$task,
        "dry-run" => \$dry_run,
    ) or pod2usage;

    ({
        'upload-to-github-release' => sub {
            infof "Upload files to GitHub Release.\n";
            upload_to_github_release();
        },
        'upload-master-to-github-release' => sub {
            infof "Upload files on master branch to GitHub Release.\n";
            upload_to_github_release(staging => 1);
        },
    }->{$task} || \&pod2usage)->();
}
