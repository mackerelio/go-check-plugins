#!/usr/bin/env perl

=head DESCRIPTION

releng script for mackerel-check-plugins

=head SYNOPSIS

    % tool/releng

=head DEPENDENCY

`git` command and `hub` or `gh` command are required.

=cut

use 5.014;
use strict;
use warnings;
use utf8;
use Carp;

use FindBin;
use lib $FindBin::Bin;
use MCUtil;

use JSON::PP qw/decode_json/;
use ExtUtils::MakeMaker qw/prompt/;
use Time::Piece qw/localtime/;
use POSIX qw(setlocale LC_TIME);

sub update_versions {
    my ($current_version, $next_version) = @_;

    ### update versions
    my $cur_ver_reg = quotemeta $current_version;

    # update rpm spec
    replace 'packaging/rpm/mackerel-check-plugins.spec' => sub {
        my $content = shift;
        $content =~ s/^(Version:\s+)$cur_ver_reg/$1$next_version/ms;
        $content;
    };
}

sub retrieve_plugins {
    sort map {s/^check-//; $_} <check-*>;
}

sub update_readme {
    my @plugins = @_;

    my $doc_links = '';
    for my $plug (@plugins) {
        $doc_links .= "* [check-$plug](./check-$plug/README.md)\n"
    }
    replace 'README.md' => sub {
        my $readme = shift;
        my $plu_reg = qr/check-[-0-9a-zA-Z_]+/;
        $readme =~ s!(?:\* \[$plu_reg\]\(\./$plu_reg/README\.md\)\n)+!$doc_links!ms;
        $readme;
    };
}

sub update_packaging_specs {
    my @plugins = @_;
    my $for_in = 'for i in ' . join(' ', @plugins) . ';do';

    my $replace_sub = sub {
        my $content = shift;
        $content =~ s/for i in.*?;do/$for_in/ms;
        $content;
    };
    replace $_, $replace_sub for qw!packaging/rpm/mackerel-check-plugins.spec packaging/deb/debian/rules!;
}

sub update_changelog {
    my ($next_version, @releases) = @_;

    my $email = 'mackerel-developers@hatena.ne.jp';
    my $name  = 'mackerel';

    my $old_locale = setlocale(LC_TIME);
    setlocale(LC_TIME, "C");
    my $g = scope_guard {
        setlocale(LC_TIME, $old_locale);
    };

    my $now = localtime;

    replace 'packaging/deb/debian/changelog' => sub {
        my $content = shift;

        my $update = "mackerel-check-plugins ($next_version-1) stable; urgency=low\n\n";
        for my $rel (@releases) {
            $update .= sprintf "  * %s (by %s)\n    <%s>\n", $rel->{title}, $rel->{user}{login}, $rel->{html_url};
        }
        $update .= sprintf "\n -- %s <%s>  %s\n\n", $name, $email, $now->strftime("%a, %d %b %Y %H:%M:%S %z");
        $update . $content;
    };

    replace 'packaging/rpm/mackerel-check-plugins.spec' => sub {
        my $content = shift;

        my $update = sprintf "* %s <%s> - %s\n", $now->strftime('%a %b %d %Y'), $email, $next_version;
        for my $rel (@releases) {
            $update .= sprintf "- %s (by %s)\n", $rel->{title}, $rel->{user}{login};
        }
        $content =~ s/%changelog/%changelog\n$update/;
        $content;
    };

    replace 'CHANGELOG.md' => sub {
        my $content = shift;

        my $update = sprintf "\n\n## %s (%s)\n\n", $next_version, $now->strftime('%Y-%m-%d');
        for my $rel (@releases) {
            $update .= sprintf "* %s #%d (%s)\n", $rel->{title}, $rel->{number}, $rel->{user}{login};
        }
        $content =~ s/\A# Changelog/# Changelog$update/;
        $content;
    };
}

sub load_packaging_confg {
    decode_json slurp 'packaging/config.json';
}

### main process
if (!$ENV{HARNESS_ACTIVE}) {
    main() unless caller;
} else {
    # When called via `prove`, tests will run.
    run_tests();
}

sub main {
    git qw/checkout master/;
    git qw/pull/;

    my $current_version = last_release;
    my $next_version    = decide_next_version($current_version);

    my $branch_name = "bump-version-$next_version";
    infof "checkout new releasing branch [$branch_name]\n";
    git qw/checkout -b/, $branch_name;

    infof "bump versions and update readme\n";
    update_versions($current_version, $next_version);
    my @plugins = retrieve_plugins;
    update_readme(@plugins);
    my $config = load_packaging_confg;
    update_packaging_specs(@{ $config->{plugins} });
    git qw/commit -am/, "ready for next release. version: $next_version";

    infof "update changelogs\n";
    my @releases = merged_prs $current_version;
    update_changelog($next_version, @releases);
    git qw/commit -am/, "update changelogs";

    git qw/diff/, qw/--word-diff/, "master..$branch_name";
    my $pr_body = build_pull_request_body($next_version, @releases);
    say $pr_body;

    if (prompt('push changes?', 'y') !~ /^y(?:es)?$/i ) {
        warnf('releng is aborted. remove the branch [%s] before next releng', $branch_name);
        return;
    }

    infof "push changes\n";
    git qw/push --set-upstream origin/, $branch_name;
    hub qw/pull-request -m/, $pr_body;

    infof "Releasing pull request is created. Review and merge it. You can update changelogs and commit more in this branch before merging.\n";
}

sub run_tests {
    require Test::More;
    Test::More->import;

    my $version = '0.1.2';
    my ($major, $minor, $patch) = parse_version($version);
    is($major, 0);
    is($minor, 1);
    is($patch, 2);
    is( suggest_next_version($version), '0.2.0' );

    my $config = load_packaging_confg;
    ok($config->{description});

    my $plugins_to_be_packaged = $config->{plugins};
    isa_ok($plugins_to_be_packaged, 'ARRAY');

    my %plugins = map { $_ => 1, } retrieve_plugins;
    for my $plug (@$plugins_to_be_packaged) {
        ok($plugins{$plug}, "$plug ok");
    }
    done_testing();
}
